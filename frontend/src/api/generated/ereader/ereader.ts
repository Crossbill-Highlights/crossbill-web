/**
 * Generated by orval v8.0.1 ðŸº
 * Do not edit manually.
 * crossbill API
 * OpenAPI spec version: 0.1.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
  BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost,
  BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost,
  BookCreate,
  CoverUploadResponse,
  EpubUploadResponse,
  EreaderBookMetadata,
  HTTPValidationError,
} from '.././model';

import { axiosInstance } from '../../axios-instance';

/**
 * Create or get a book by client_book_id.

This endpoint creates a new book if it doesn't exist, or returns the existing
book's metadata if it does. Used by KOReader to ensure a book exists before
uploading highlights, covers, or EPUB files.

Args:
    book_data: Book creation data (same format as highlight upload)
    db: Database session
    current_user: Authenticated user

Returns:
    EreaderBookMetadata with book_id, bookname, author, has_cover, has_epub
 * @summary Create Book
 */
export const createBookApiV1EreaderBooksPost = (bookCreate: BookCreate, signal?: AbortSignal) => {
  return axiosInstance<EreaderBookMetadata>({
    url: `/api/v1/ereader/books`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: bookCreate,
    signal,
  });
};

export const getCreateBookApiV1EreaderBooksPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>,
    TError,
    { data: BookCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>,
  TError,
  { data: BookCreate },
  TContext
> => {
  const mutationKey = ['createBookApiV1EreaderBooksPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>,
    { data: BookCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createBookApiV1EreaderBooksPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBookApiV1EreaderBooksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>
>;
export type CreateBookApiV1EreaderBooksPostMutationBody = BookCreate;
export type CreateBookApiV1EreaderBooksPostMutationError = HTTPValidationError;

/**
 * @summary Create Book
 */
export const useCreateBookApiV1EreaderBooksPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>,
      TError,
      { data: BookCreate },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createBookApiV1EreaderBooksPost>>,
  TError,
  { data: BookCreate },
  TContext
> => {
  return useMutation(getCreateBookApiV1EreaderBooksPostMutationOptions(options), queryClient);
};
/**
 * Get basic book metadata by client_book_id for ereader operations.

This endpoint returns lightweight book information that KOReader uses to
decide whether it needs to upload cover images, epub files, etc.

Args:
    client_book_id: The client-provided stable book identifier
    db: Database session
    current_user: Authenticated user

Returns:
    EreaderBookMetadata with book_id, bookname, author, hasCover, hasEpub

Raises:
    HTTPException: 404 if book is not found
 * @summary Get Book Metadata
 */
export const getBookMetadataApiV1EreaderBooksClientBookIdGet = (
  clientBookId: string,
  signal?: AbortSignal
) => {
  return axiosInstance<EreaderBookMetadata>({
    url: `/api/v1/ereader/books/${clientBookId}`,
    method: 'GET',
    signal,
  });
};

export const getGetBookMetadataApiV1EreaderBooksClientBookIdGetQueryKey = (
  clientBookId?: string
) => {
  return [`/api/v1/ereader/books/${clientBookId}`] as const;
};

export const getGetBookMetadataApiV1EreaderBooksClientBookIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
  TError = HTTPValidationError,
>(
  clientBookId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBookMetadataApiV1EreaderBooksClientBookIdGetQueryKey(clientBookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>
  > = ({ signal }) => getBookMetadataApiV1EreaderBooksClientBookIdGet(clientBookId, signal);

  return { queryKey, queryFn, enabled: !!clientBookId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookMetadataApiV1EreaderBooksClientBookIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>
>;
export type GetBookMetadataApiV1EreaderBooksClientBookIdGetQueryError = HTTPValidationError;

export function useGetBookMetadataApiV1EreaderBooksClientBookIdGet<
  TData = Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
  TError = HTTPValidationError,
>(
  clientBookId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookMetadataApiV1EreaderBooksClientBookIdGet<
  TData = Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
  TError = HTTPValidationError,
>(
  clientBookId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookMetadataApiV1EreaderBooksClientBookIdGet<
  TData = Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
  TError = HTTPValidationError,
>(
  clientBookId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Book Metadata
 */

export function useGetBookMetadataApiV1EreaderBooksClientBookIdGet<
  TData = Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
  TError = HTTPValidationError,
>(
  clientBookId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookMetadataApiV1EreaderBooksClientBookIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookMetadataApiV1EreaderBooksClientBookIdGetQueryOptions(
    clientBookId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Upload a book cover image using client_book_id.

This endpoint accepts an uploaded image file and saves it as the book's cover.
Used by KOReader which identifies books by client_book_id.

Args:
    client_book_id: The client-provided stable book identifier
    cover: Uploaded image file (JPEG, PNG, or WebP)
    db: Database session
    current_user: Authenticated user

Returns:
    CoverUploadResponse with success status and cover URL

Raises:
    HTTPException: 404 if book is not found, or if upload fails
 * @summary Upload Book Cover
 */
export const uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost = (
  clientBookId: string,
  bodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`cover`, bodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost.cover);

  return axiosInstance<CoverUploadResponse>({
    url: `/api/v1/ereader/books/${clientBookId}/cover`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadBookCoverApiV1EreaderBooksClientBookIdCoverPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>,
    TError,
    { clientBookId: string; data: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>,
  TError,
  { clientBookId: string; data: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost },
  TContext
> => {
  const mutationKey = ['uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>,
    { clientBookId: string; data: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost }
  > = (props) => {
    const { clientBookId, data } = props ?? {};

    return uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost(clientBookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadBookCoverApiV1EreaderBooksClientBookIdCoverPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>
>;
export type UploadBookCoverApiV1EreaderBooksClientBookIdCoverPostMutationBody =
  BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost;
export type UploadBookCoverApiV1EreaderBooksClientBookIdCoverPostMutationError =
  HTTPValidationError;

/**
 * @summary Upload Book Cover
 */
export const useUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>,
      TError,
      { clientBookId: string; data: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof uploadBookCoverApiV1EreaderBooksClientBookIdCoverPost>>,
  TError,
  { clientBookId: string; data: BodyUploadBookCoverApiV1EreaderBooksClientBookIdCoverPost },
  TContext
> => {
  return useMutation(
    getUploadBookCoverApiV1EreaderBooksClientBookIdCoverPostMutationOptions(options),
    queryClient
  );
};
/**
 * Upload an ebook file (EPUB) for a book using client_book_id.

This endpoint accepts an uploaded ebook file and saves it for the book.
Used by KOReader which identifies books by client_book_id.

Args:
    client_book_id: The client-provided stable book identifier
    epub: Uploaded ebook file (EPUB or PDF)
    db: Database session
    current_user: Authenticated user

Returns:
    EpubUploadResponse with success status

Raises:
    HTTPException: 400 for invalid file, 404 if book is not found
 * @summary Upload Book Epub
 */
export const uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost = (
  clientBookId: string,
  bodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  formData.append(`epub`, bodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost.epub);

  return axiosInstance<EpubUploadResponse>({
    url: `/api/v1/ereader/books/${clientBookId}/epub`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadBookEpubApiV1EreaderBooksClientBookIdEpubPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>,
    TError,
    { clientBookId: string; data: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>,
  TError,
  { clientBookId: string; data: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost },
  TContext
> => {
  const mutationKey = ['uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>,
    { clientBookId: string; data: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost }
  > = (props) => {
    const { clientBookId, data } = props ?? {};

    return uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost(clientBookId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadBookEpubApiV1EreaderBooksClientBookIdEpubPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>
>;
export type UploadBookEpubApiV1EreaderBooksClientBookIdEpubPostMutationBody =
  BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost;
export type UploadBookEpubApiV1EreaderBooksClientBookIdEpubPostMutationError = HTTPValidationError;

/**
 * @summary Upload Book Epub
 */
export const useUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>,
      TError,
      { clientBookId: string; data: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof uploadBookEpubApiV1EreaderBooksClientBookIdEpubPost>>,
  TError,
  { clientBookId: string; data: BodyUploadBookEpubApiV1EreaderBooksClientBookIdEpubPost },
  TContext
> => {
  return useMutation(
    getUploadBookEpubApiV1EreaderBooksClientBookIdEpubPostMutationOptions(options),
    queryClient
  );
};
